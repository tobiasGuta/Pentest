import socket
import os
import struct
import string

# Host to listen on
host = 'ip address'

# IP header parsing function
def parse_ip_header(data):
    ip_header = struct.unpack('!BBHHHBBH4s4s', data[:20])
    version = ip_header[0] >> 4
    ihl = (ip_header[0] & 0xF) * 4
    ttl = ip_header[5]
    protocol = ip_header[6]
    src_ip = socket.inet_ntoa(ip_header[8])
    dst_ip = socket.inet_ntoa(ip_header[9])
    return version, ihl, ttl, protocol, src_ip, dst_ip

# TCP header parsing function
def parse_tcp_header(data):
    tcp_header = struct.unpack('!HHLLBBHHH', data)
    src_port = tcp_header[0]
    dst_port = tcp_header[1]
    return src_port, dst_port

# UDP header parsing function
def parse_udp_header(data):
    udp_header = struct.unpack('!HHHH', data)
    src_port = udp_header[0]
    dst_port = udp_header[1]
    return src_port, dst_port

def printable_payload(payload):
    printable_chars = ''.join(char if char in string.printable else '.' for char in payload.decode('utf-8', errors='ignore'))
    return ''.join(filter(lambda x: x in string.printable, printable_chars))

def format_hex_ascii(data):
    hex_str = ' '.join(f'{byte:02X}' for byte in data)
    ascii_str = ''.join(chr(byte) if 32 <= byte <= 126 else '.' for byte in data)
    return hex_str, ascii_str

def parse_http_payload(payload):
    try:
        decoded_payload = payload.decode('utf-8', errors='ignore')
        print("\tHTTP payload:")
        print("\t" + decoded_payload)
    except UnicodeDecodeError:
        print("\tHTTP Payload (Hex):")
        print("\t" + payload.hex())

# Add more parse functions for other protocols similarly

def main():
    if os.name == 'nt':
        socket_protocol = socket.IPPROTO_IP
    else:
        socket_protocol = socket.IPPROTO_ICMP

    sniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket_protocol)
    sniffer.bind((host, 0))
    
    if os.name == 'nt':
        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)

    try:
        while True:
            raw_data, addr = sniffer.recvfrom(65565)
            version, ihl, ttl, protocol, src_ip, dst_ip = parse_ip_header(raw_data)
            
            print("Captured Packet:")
            print("\tInternet Protocol Version " + str(version))
            print("\tHeader Length: " + str(ihl) + " bytes")
            print("\tTime to Live: " + str(ttl))
            print("\tProtocol: " + str(protocol))
            print("\tSource IP: " + src_ip)
            print("\tDestination IP: " + dst_ip)
            
            if protocol == 1:
                print("\tICMP")
            elif protocol == 6:
                tcp_header = raw_data[ihl:ihl+20]
                src_port, dst_port = parse_tcp_header(tcp_header)
                print(f'\tTransmission Control Protocol, Src Port: {src_port}, Dst Port: {dst_port}')
                
                # Extract and print payload (data)
                payload = raw_data[ihl + 20:]
                hex_str, ascii_str = format_hex_ascii(payload)
                hex_lines = hex_str.split('\n')
                ascii_lines = ascii_str.split('\n')
                print("\tHex payload:\t\tASCII payload:")
                for hex_line, ascii_line in zip(hex_lines, ascii_lines):
                    print(f"\t{hex_line}  |  {ascii_line}")
                
                if dst_port == 80 and payload.startswith(b'HTTP'):
                    parse_http_payload(payload)
                
            elif protocol == 17:
                udp_header = raw_data[ihl:ihl+8]
                src_port, dst_port = parse_udp_header(udp_header)
                print(f'\tUser Datagram Protocol, Src Port: {src_port}, Dst Port: {dst_port}')
                
                # Extract and print payload (data)
                payload = raw_data[ihl + 8:]
                hex_str, ascii_str = format_hex_ascii(payload)
                hex_lines = hex_str.split('\n')
                ascii_lines = ascii_str.split('\n')
                print("\tHex payload:\t\tASCII payload:")
                for hex_line, ascii_line in zip(hex_lines, ascii_lines):
                    print(f"\t{hex_line}  |  {ascii_line}")
                
            else:
                print(f'\tProtocol {protocol} not supported')
            
    except KeyboardInterrupt:
        print("Exiting...")
    
    if os.name == 'nt':
        sniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)
    
if __name__ == '__main__':
    main()
